---
title: "Import and Tidy Data"
author: "Gabriel Odom"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Importing Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
  
```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE,
                      cache = FALSE,
                      comment = "#>")
```

# Overview

This vignette will discuss importing Gene Matrix Transposed (`.gmt`) [gene set files](https://software.broadinstitute.org/cancer/software/gsea/wiki/index.php/Data_formats#GMT:_Gene_Matrix_Transposed_file_format_.28.2A.gmt.29) to a list object with class `pathwaySet` with the `read_gmt` function. Also, we will discuss importing assay and response data, and how to make your assay data [tidy](https://www.jstatsoft.org/article/view/v059i10).

First, load the `pathwayPCA` package and the [`tidyverse` package suite](https://www.tidyverse.org/). If you don't have the `tidyverse` package suite, install that first.
```{r packageLoad}
# install.packages("tidyverse")
library(tidyverse)
library(pathwayPCA)
```

*******************************************************************************

</br>

# Importing GMT Files
GMT files are one form of gene set file officially recognized by the Gene Set Enrichment Analysis committee of the Broad Institute. These Molecular Signatures Database (MSigDB) GMT files can be downloaded from the [MSigDB Collections](http://software.broadinstitute.org/gsea/msigdb/collections.jsp) page.

## GMT Format Description
GMT-formatted files follow a very specific set of rules:

1. Each row of the file represents a gene set, and only one gene set is allowed per line.
2. The first entry in each row is the gene set name. Eg. `"KEGG_STEROID_BIOSYNTHESIS"`
3. The second entry in each row is a brief description of the gene set. Eg. `"http://www.broadinstitute.org/gsea/msigdb/cards/KEGG_STEROID_BIOSYNTHESIS"`
4. The third to the last entry on each row are the genes in the gene set. Eg. `"SOAT1"  "LSS" "SQLE"  "EBP" "CYP51A1" "DHCR7" "CYP27B1" "DHCR24"  "HSD17B7" "MSMO1" "FDFT1" "SC5DL" "LIPA"  "CEL" "TM7SF2"  "NSDHL" "SOAT2"`
5. Each entry in each line is seperated by a tab.

## The `read_gmt` Function
Based on the clearly-organized `.gmt` data format, we are able to write a very fast function to read `.gmt` files into R. The `read_gmt` function takes in a path specifying where your `.gmt` file is stored, and outputs a list of gene set information.
```{r read_example_gmt, eval = FALSE}
gene_set_ls <- read_gmt("path_to_your_directory/your_file_name.gmt")
```
```{r read_real_gmt, echo = FALSE}
gene_set_ls <- read_gmt("C:/Users/gjo15/Documents/GitHub/pathwayPCA/inst/extdata/c2.cp.v6.0.symbols.gmt")
```

This `gene_set_ls` object is a list with class `pathwaySet`. Pathway set lists have three elements:

1. `pathways`: A named list of character vectors. Each vector contains the names of the individual genes within that pathway as a vector of character strings.
2. `TERMS`: A character vector the same length as the pathways list with the proper names of the pathways.
3. `GSEA_link`: A character vector the same length as the pathways list with hyperlinks to the MSigDB description card for that pathway.

The object itself has the following structure:
```{r pathwaySet_structure}
str(gene_set_ls, max.level = 1)
```

This object will be the list supplied to the `pathwaySet_ls` argument in the `create_OmicsPath`, `create_OmicsSurv`, `create_OmicsReg`, or `create_OmicsCateg` functions.

*******************************************************************************

</br>

# Import and Tidy Assay Matrices
We assume that the assay data (be it genomic, proteomic, metabolomic, lipidomic, or transcriptomic data) is either in an Excel file or flat text file. For example, your data may look like this:

![](example_assay_data.PNG)

In this data set, the columns are individual samples, patients, tumors, cell lines, etc. The rows are the -Omic expression measures.


## Import with `readr`
To import these files in `.xlsx`, `.csv`, or `.txt` (tab-delimited), we recommend the [`readr` package](https://readr.tidyverse.org/). We would read this data via
```{r read_example_assay, eval = FALSE}
assay_df <- read_csv("path_to_your_directory/your_assay.csv")
```
```{r read_real_assay, echo = FALSE}
assay_df <- read_csv("C:/Users/gjo15/Documents/GitHub/pathwayPCA/inst/extdata/ex_assay_subset.csv")
```

Let's inspect our assay data frame.
```{r assay_print}
assay_df
```

This data import step stored the row names (the gene names) as the first column, and preserved the column names (sample labels) of the data.


## Tidy the Assay Data Frame
The assay input to the `pathwayPCA` package must be in [*tidy data*](https://www.jstatsoft.org/article/view/v059i10) format. The "Tidy Data" format requires that each observation be its own row, and each measurement its own column. This means that we must transpose our assay data frame, while preserving the row and column names.

To do this, we can use the `transpose_assay` function. This function takes in a data frame as imported by the `readr` function based on data in a format similar to that shown above: genes are the rows, gene names are the first column, samples are are the stored in the subsequent columns, and all values in the assay (other than the single names column) are numeric.
```{r transpose}
(assayT_df <- transpose_assay(assay_df))
```

This transposed data frame has the gene names as the column names and the sample names as a column of character (`chr`) values. Notice that the data itself is 17 genes measured on 36 samples. Before transposition, we had 37 columns because the feature names were stored in the first column. After transposition, we have 36 rows but 18 columns: the first column stores the sample names. This transposed data frame (after filtering to match the response data) will be supplied to the `assayData_df` argument in the `create_OmicsPath`, `create_OmicsSurv`, `create_OmicsReg`, or `create_OmicsCateg` functions.

## Subsetting a Tidy Data Frame
If ever we need to extract individual components of a tidy data frame, we can use the `assay[row, col]` syntax. If we need entire measurements (columns), then we can call the column by name with the `assay$ColName` syntax. For example

- If we need the second row of `assayT_df`---corresponding to Sample "T21101312"---then we type
```{r subset_2ndrow}
assayT_df[2, ]
```
- If we need the third column of `assayT_df`---corresponding to Gene "LSS"---then we type
```{r subset_3rdcol}
assayT_df[, 3]
```
- If we need the intersection of these two (the expression level of Gene "LSS" in Sample "T21101312"), then we type
```{r subset_23}
assayT_df[2, 3]
```
- If we need the third column of `assayT_df`, but we want the result back as a vector, we have to call the column by name:
```{r subset_3rdcol_byname}
assayT_df$LSS
```

*******************************************************************************

</br>

# Import and Join Response Data
We now have an appropriate pathway set list and a tidy -Omics assay data frame. Let's imagine that your response data looks something like this:

![](example_pInfo_data.PNG)


We now need to import the response information. We can use the `read_csv` function once again:
```{r read_example_pinfo, eval = FALSE}
pInfo_df <- read_csv("path_to_your_directory/your_subject_info.csv")
```
```{r read_real_pinfo, echo = FALSE}
pInfo_df <- read_csv("C:/Users/gjo15/Documents/GitHub/pathwayPCA/inst/extdata/ex_pInfo_subset.csv")
```

This data frame has a column for the sample labels (`Sample`) and the response information. In this case, our response is a survival response with an event time and observation indicator.
```{r pInfo}
pInfo_df
```

## Data Types and the `create_Omics*` Functions
Look at the types of the columns of this data frame (directly under the column names, notice the  `<chr>`, `<dbl>`, and `<lgl>` tags). These tags tell us that the columns contain "character" (`chr`), "double / numeric" (`dbl`), and "logical" (`lgl`) information. These tags are important because they identify the type of data is in each column, and the response fields of the `create_OmicsSurv`, `create_OmicsReg`, or `create_OmicsCateg` functions require specific types of data:

* `create_OmicsSurv` requires two response vectors:
    - `eventTime_vec` = a *numeric* vector. The column in your imported data corresponding to the event time should have the `<int>` or `<dbl>` tag. If this column is a character column (it has the `<char>` tag), then the most likely cause is that you had an additional column of character information in your assay data frame before transposing. Remove this extra character information and transpose your assay again.
    - `eventObserved_vec` = a *logical* vector. The column in your imported data corresponding to the event indicator should have the `<lgl>` tag. Also note that this indicator records if an event **was observed**, not if the event was censored. If the event occured at the corresponding event time (i.e. the subject died), then this vector entry will be `TRUE`. If the subject was right-censored, then this entry will be `FALSE`.
* `create_OmicsReg` and `create_OmicsCateg` require one response vector:
    - `response_num` = regression response as a *numeric* vector. The column in your imported data corresponding to the regression response should have the `<int>` or `<dbl>` tag. See the comment above about the `eventTime_vec` argument if your column is a character.
    - `response_fact` = classification response as a *factor* vector. The column in your imported data corresponding to the classification / categorical regression response should have the `<fct>` tag. It is highly likely that the classification response was imported as an integer (if the original values were coded as 0/1) or a character (if the original values were given character names, such as "benign" / "malignent"). Either way, use the `as.factor` command to transform that column from a character or integer column into a factor column. For example, the `as.factor` function can turn our logical censoring indicator from a vector of `TRUE` and `FALSE` to a categorical (factor) vector with levels `TRUE` and `FALSE`. This will not overwrite the original column, so make sure you save this new factor.
```{r factors_eg}
(eventObs_fct <- as.factor(pInfo_df$eventObserved))
```


## Join the Response and Assay Data Frames
This `pInfo` data frame has the sample names as a column of `chr` values, just like the transposed assay data frame. This is crucially important for the "joining" step. We can use the `inner_join` function from the `dplyr` library to only retain the rows of the `assayT_df` data frame which have responses in the `pInfo` data frame and vice versa. This way, every response has matching assay predictors, and every recorded assay sample has a matching response.
```{r innerJoin}
(joinedExperiment_df <- inner_join(pInfo_df, assayT_df, by = "Sample"))
```

It is vitally important that you check your sample IDs. Obviously the expressed genetic data should pair with the subject information, but **it is your responsibility as the user to confirm that the assay rows match the correct responses.** We can show you the proper methods to check your data, but you are ultimately responsible to use this package properly.

*******************************************************************************

</br>

# Create an `Omics*`-Class Object

## Review
Before we move on, we will summarize our steps so far. We have

1. Imported a `.gmt` file and saved the gene sets therein as a `pathwaySet` object using the `read_gmt` function.
2. Imported an assay `.csv` file with the `read_csv` function from the `readr` package, and transposed this data frame into "tidy" form with the `transpose_assay` function.
3. Imported a subject information `.csv` file, and joined it to the assay data frame with the `inner_join` function from the `dplyr` package.

## Create an `OmicsSurv` Object
Now we are prepared to create our first `OmicsSurv` object for analysis with either AES-PCA or Supervised PCA. Recall that the `joinedExperiment_df` has the sample ID in the first column, the survival time in the second column, the event indicator in the third column, and the assay expression data in the subsequent columns. Therefore, the four arguments to the `create_OmicsSurv` function will have the following data objects supplied to them:

- `assayData_df` will be only the *expression columns* of the `joinedExperiment_df` data frame (i.e. all but the first three columns). In R, we can remove the first three columns of the `joinedExperiment_df` data frame by negative subsetting: `joinedExperiment_df[, -(1:3)]`.
- `pathwaySet_ls` will be the `pathwaySet` list object (`gene_set_ls`) we imported with the `read_gmt` function earlier.
- `eventTime_vec` will be the survival time stored in the `eventTime` column of the `joinedExperiment_df` data frame: `joinedExperiment_df$eventTime`.
- `eventObserved_vec` will be the event indicator stored in the `eventObserved` column of the `joinedExperiment_df` data frame: `joinedExperiment_df$eventObserved`.

```{r create_OmicsSurv_object}
test_OmicsSurv <- create_OmicsSurv(assayData_df = joinedExperiment_df[, -(1:3)],
                                   pathwaySet_ls = gene_set_ls,
                                   eventTime_vec = joinedExperiment_df$eventTime,
                                   eventObserved_vec = joinedExperiment_df$eventObserved)
```

## Inspect the New Object
<!-- rm(eventObs_fct, pInfo_df, joinedExperiment_df, assay_df, assayT_df) --->
